---
description: 
globs: 
alwaysApply: true
---
# AIæç¤ºè¯ä¼˜åŒ–å™¨ - åç«¯é¡¹ç›®è®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†AIæç¤ºè¯ä¼˜åŒ–å™¨åç«¯é¡¹ç›®çš„æŠ€æœ¯æ¶æ„ã€APIè®¾è®¡ã€æ•°æ®åº“ç»“æ„å’Œå¼€å‘è§„èŒƒï¼ŒåŸºäºPython + FastAPIæŠ€æœ¯æ ˆæ„å»ºé«˜æ€§èƒ½ã€å¯æ‰©å±•çš„åç«¯æœåŠ¡ã€‚

---

## ğŸ›  æŠ€æœ¯æ ˆé€‰æ‹©

### æ ¸å¿ƒæŠ€æœ¯æ ˆ

#### 1. **FastAPI æ¡†æ¶**
```python
fastapi = "^0.104.1"
uvicorn = "^0.24.0"
pydantic = "^2.5.0"
```

**é€‰æ‹©ç†ç”±**ï¼š
- é«˜æ€§èƒ½å¼‚æ­¥æ¡†æ¶ï¼Œæ”¯æŒå¹¶å‘å¤„ç†
- è‡ªåŠ¨ç”ŸæˆOpenAPIæ–‡æ¡£
- åŸç”Ÿæ”¯æŒç±»å‹æç¤ºå’Œæ•°æ®éªŒè¯
- ç°ä»£åŒ–çš„å¼€å‘ä½“éªŒ

#### 2. **æ•°æ®åº“æŠ€æœ¯æ ˆ**
```python
sqlalchemy = "^2.0.23"
alembic = "^1.13.0"
asyncpg = "^0.29.0"
aiosqlite = "^0.19.0"
```

**æ•°æ®åº“é€‰æ‹©**ï¼š
- **å¼€å‘ç¯å¢ƒ**ï¼šSQLite (è½»é‡çº§ï¼Œæ˜“äºå¼€å‘)
- **ç”Ÿäº§ç¯å¢ƒ**ï¼šPostgreSQL (ç¨³å®šå¯é ï¼ŒåŠŸèƒ½å¼ºå¤§)

#### 3. **AIæœåŠ¡é›†æˆ**
```python
openai = "^1.3.0"
httpx = "^0.25.0"
tiktoken = "^0.5.0"
```

#### 4. **è®¤è¯å’Œå®‰å…¨**
```python
python-jose = "^3.3.0"
passlib = "^1.7.4"
python-multipart = "^0.0.6"
bcrypt = "^4.1.0"
```

#### 5. **å·¥å…·å’Œä¸­é—´ä»¶**
```python
redis = "^5.0.0"
celery = "^5.3.0"
python-dotenv = "^1.0.0"
loguru = "^0.7.0"
```

#### 6. **å¼€å‘å’Œæµ‹è¯•å·¥å…·**
```python
pytest = "^7.4.0"
pytest-asyncio = "^0.21.0"
black = "^23.0.0"
isort = "^5.12.0"
flake8 = "^6.0.0"
mypy = "^1.7.0"
```

---

## ğŸ— é¡¹ç›®æ–‡ä»¶ç»“æ„

### æ•´ä½“ç›®å½•ç»“æ„
```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py              # FastAPIåº”ç”¨å…¥å£
â”‚   â”œâ”€â”€ config.py            # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ database.py          # æ•°æ®åº“è¿æ¥
â”‚   â”œâ”€â”€ dependencies.py      # ä¾èµ–æ³¨å…¥
â”‚   â”‚
â”‚   â”œâ”€â”€ api/                 # APIè·¯ç”±
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ router.py        # ä¸»è·¯ç”±
â”‚   â”‚   â””â”€â”€ v1/             # APIç‰ˆæœ¬1
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ auth.py      # è®¤è¯ç›¸å…³
â”‚   â”‚       â”œâ”€â”€ optimizer.py # ä¼˜åŒ–æ¥å£
â”‚   â”‚       â”œâ”€â”€ history.py   # å†å²è®°å½•
â”‚   â”‚       â”œâ”€â”€ examples.py  # æ¡ˆä¾‹åº“
â”‚   â”‚       â””â”€â”€ users.py     # ç”¨æˆ·ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ core/               # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ prompt_optimizer.py  # æç¤ºè¯ä¼˜åŒ–å™¨
â”‚   â”‚   â”œâ”€â”€ quality_evaluator.py # è´¨é‡è¯„ä¼°å™¨
â”‚   â”‚   â”œâ”€â”€ ai_client.py         # AIæœåŠ¡å®¢æˆ·ç«¯
â”‚   â”‚   â””â”€â”€ prompt_analyzer.py   # æç¤ºè¯åˆ†æå™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ models/             # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py         # åŸºç¡€æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ user.py         # ç”¨æˆ·æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ optimization.py # ä¼˜åŒ–è®°å½•æ¨¡å‹
â”‚   â”‚   â””â”€â”€ example.py      # æ¡ˆä¾‹æ¨¡å‹
â”‚   â”‚
â”‚   â”œâ”€â”€ schemas/            # Pydanticæ¨¡å¼
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ optimization.py
â”‚   â”‚   â”œâ”€â”€ example.py
â”‚   â”‚   â””â”€â”€ common.py       # é€šç”¨æ¨¡å¼
â”‚   â”‚
â”‚   â”œâ”€â”€ services/           # ä¸šåŠ¡æœåŠ¡å±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth_service.py
â”‚   â”‚   â”œâ”€â”€ optimizer_service.py
â”‚   â”‚   â”œâ”€â”€ history_service.py
â”‚   â”‚   â””â”€â”€ example_service.py
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ security.py     # å®‰å…¨å·¥å…·
â”‚   â”‚   â”œâ”€â”€ validators.py   # éªŒè¯å™¨
â”‚   â”‚   â”œâ”€â”€ exceptions.py   # è‡ªå®šä¹‰å¼‚å¸¸
â”‚   â”‚   â””â”€â”€ helpers.py      # è¾…åŠ©å‡½æ•°
â”‚   â”‚
â”‚   â””â”€â”€ middleware/         # ä¸­é—´ä»¶
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ cors.py         # è·¨åŸŸå¤„ç†
â”‚       â”œâ”€â”€ auth.py         # è®¤è¯ä¸­é—´ä»¶
â”‚       â””â”€â”€ logging.py      # æ—¥å¿—ä¸­é—´ä»¶
â”‚
â”œâ”€â”€ migrations/             # æ•°æ®åº“è¿ç§»
â”‚   â””â”€â”€ versions/
â”‚
â”œâ”€â”€ tests/                  # æµ‹è¯•ä»£ç 
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py         # æµ‹è¯•é…ç½®
â”‚   â”œâ”€â”€ test_api/           # APIæµ‹è¯•
â”‚   â”œâ”€â”€ test_core/          # æ ¸å¿ƒé€»è¾‘æµ‹è¯•
â”‚   â””â”€â”€ test_services/      # æœåŠ¡å±‚æµ‹è¯•
â”‚
â”œâ”€â”€ scripts/                # è„šæœ¬æ–‡ä»¶
â”‚   â”œâ”€â”€ init_db.py         # æ•°æ®åº“åˆå§‹åŒ–
â”‚   â””â”€â”€ seed_data.py       # æµ‹è¯•æ•°æ®
â”‚
â”œâ”€â”€ requirements.txt        # ä¾èµ–åˆ—è¡¨
â”œâ”€â”€ pyproject.toml         # é¡¹ç›®é…ç½®
â”œâ”€â”€ Dockerfile             # Dockeré…ç½®
â”œâ”€â”€ docker-compose.yml     # Dockerç¼–æ’
â””â”€â”€ README.md              # é¡¹ç›®è¯´æ˜
```

---

## ğŸ”§ æ ¸å¿ƒæ¶æ„è®¾è®¡

### åˆ†å±‚æ¶æ„æ¨¡å¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    API Layer        â”‚  â† FastAPIè·¯ç”±ï¼Œè¯·æ±‚å“åº”å¤„ç†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Service Layer      â”‚  â† ä¸šåŠ¡é€»è¾‘å±‚ï¼Œåè°ƒå„ä¸ªç»„ä»¶
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Core Layer        â”‚  â† æ ¸å¿ƒç®—æ³•ï¼Œæç¤ºè¯ä¼˜åŒ–é€»è¾‘
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Model Layer       â”‚  â† æ•°æ®æ¨¡å‹ï¼ŒORMæ˜ å°„
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Database Layer      â”‚  â† æ•°æ®æŒä¹…åŒ–
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¾èµ–æ³¨å…¥è®¾è®¡

```python
# dependencies.py
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_async_session
from app.core.ai_client import AIClient

async def get_db_session() -> AsyncSession:
    async with get_async_session() as session:
        yield session

def get_ai_client() -> AIClient:
    return AIClient()

def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db_session)
):
    # ç”¨æˆ·è®¤è¯é€»è¾‘
    pass
```

---

## ğŸ“Š æ•°æ®åº“è®¾è®¡

### æ•°æ®æ¨¡å‹è®¾è®¡

#### 1. **ç”¨æˆ·è¡¨ (users)**
```python
class User(Base):
    __tablename__ = "users"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    username: Mapped[str] = mapped_column(String(50), unique=True, index=True)
    email: Mapped[str] = mapped_column(String(100), unique=True, index=True)
    hashed_password: Mapped[str] = mapped_column(String(255))
    is_active: Mapped[bool] = mapped_column(default=True)
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # å…³ç³»
    optimizations: Mapped[List["Optimization"]] = relationship(back_populates="user")
```

#### 2. **ä¼˜åŒ–è®°å½•è¡¨ (optimizations)**
```python
class Optimization(Base):
    __tablename__ = "optimizations"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    original_prompt: Mapped[str] = mapped_column(Text)
    optimized_prompt: Mapped[str] = mapped_column(Text)
    quality_score_before: Mapped[int] = mapped_column(nullable=True)
    quality_score_after: Mapped[int] = mapped_column(nullable=True)
    optimization_type: Mapped[str] = mapped_column(String(50))
    ai_model_used: Mapped[str] = mapped_column(String(50))
    processing_time: Mapped[float] = mapped_column(nullable=True)
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
    
    # å…³ç³»
    user: Mapped["User"] = relationship(back_populates="optimizations")
    improvements: Mapped[List["OptimizationImprovement"]] = relationship(back_populates="optimization")
```

#### 3. **ä¼˜åŒ–æ”¹è¿›ç‚¹è¡¨ (optimization_improvements)**
```python
class OptimizationImprovement(Base):
    __tablename__ = "optimization_improvements"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    optimization_id: Mapped[int] = mapped_column(ForeignKey("optimizations.id"))
    improvement_type: Mapped[str] = mapped_column(String(50))  # structure, clarity, context
    description: Mapped[str] = mapped_column(Text)
    before_text: Mapped[str] = mapped_column(Text, nullable=True)
    after_text: Mapped[str] = mapped_column(Text, nullable=True)
    
    # å…³ç³»
    optimization: Mapped["Optimization"] = relationship(back_populates="improvements")
```

#### 4. **æ¡ˆä¾‹åº“è¡¨ (examples)**
```python
class Example(Base):
    __tablename__ = "examples"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(200))
    category: Mapped[str] = mapped_column(String(50), index=True)
    original_prompt: Mapped[str] = mapped_column(Text)
    optimized_prompt: Mapped[str] = mapped_column(Text)
    description: Mapped[str] = mapped_column(Text, nullable=True)
    tags: Mapped[str] = mapped_column(String(500), nullable=True)  # JSONå­—ç¬¦ä¸²
    difficulty_level: Mapped[str] = mapped_column(String(20))  # beginner, intermediate, advanced
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
```

### æ•°æ®åº“è¿æ¥é…ç½®

```python
# database.py
import asyncio
from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass

class DatabaseManager:
    def __init__(self, database_url: str):
        self.engine = create_async_engine(
            database_url,
            echo=False,
            pool_pre_ping=True,
            pool_recycle=300,
        )
        self.async_session_maker = async_sessionmaker(
            self.engine, 
            class_=AsyncSession, 
            expire_on_commit=False
        )
    
    async def get_session(self) -> AsyncGenerator[AsyncSession, None]:
        async with self.async_session_maker() as session:
            try:
                yield session
                await session.commit()
            except Exception:
                await session.rollback()
                raise
            finally:
                await session.close()
```

---

## ğŸš€ APIæ¥å£è®¾è®¡

### RESTful APIè§„èŒƒ

#### 1. **æç¤ºè¯ä¼˜åŒ–æ¥å£**
```python
# api/v1/optimizer.py
from fastapi import APIRouter, Depends, HTTPException
from app.schemas.optimization import OptimizationRequest, OptimizationResponse
from app.services.optimizer_service import OptimizerService

router = APIRouter(prefix="/optimizer", tags=["optimizer"])

@router.post("/optimize", response_model=OptimizationResponse)
async def optimize_prompt(
    request: OptimizationRequest,
    optimizer_service: OptimizerService = Depends(),
    current_user: User = Depends(get_current_user)
):
    """
    ä¼˜åŒ–æç¤ºè¯
    
    Args:
        request: ä¼˜åŒ–è¯·æ±‚å‚æ•°
        optimizer_service: ä¼˜åŒ–æœåŠ¡
        current_user: å½“å‰ç”¨æˆ·
    
    Returns:
        ä¼˜åŒ–ç»“æœ
    """
    try:
        result = await optimizer_service.optimize_prompt(
            original_prompt=request.original_prompt,
            optimization_type=request.optimization_type,
            user_id=current_user.id
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/evaluate", response_model=QualityEvaluationResponse)
async def evaluate_prompt_quality(
    request: QualityEvaluationRequest,
    optimizer_service: OptimizerService = Depends()
):
    """è¯„ä¼°æç¤ºè¯è´¨é‡"""
    return await optimizer_service.evaluate_quality(request.prompt)
```

#### 2. **å†å²è®°å½•æ¥å£**
```python
# api/v1/history.py
@router.get("/", response_model=List[OptimizationHistoryResponse])
async def get_optimization_history(
    skip: int = Query(0, ge=0),
    limit: int = Query(20, ge=1, le=100),
    category: Optional[str] = Query(None),
    current_user: User = Depends(get_current_user),
    history_service: HistoryService = Depends()
):
    """è·å–ä¼˜åŒ–å†å²è®°å½•"""
    return await history_service.get_user_history(
        user_id=current_user.id,
        skip=skip,
        limit=limit,
        category=category
    )
```

### è¯·æ±‚å“åº”æ¨¡å¼

```python
# schemas/optimization.py
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime

class OptimizationRequest(BaseModel):
    original_prompt: str = Field(..., min_length=1, max_length=10000)
    optimization_type: str = Field(default="general", regex="^(general|code|writing|analysis)$")
    user_context: Optional[str] = Field(None, max_length=1000)

class OptimizationImprovement(BaseModel):
    type: str
    description: str
    before_text: Optional[str] = None
    after_text: Optional[str] = None

class OptimizationResponse(BaseModel):
    id: int
    original_prompt: str
    optimized_prompt: str
    quality_score_before: int
    quality_score_after: int
    improvements: List[OptimizationImprovement]
    processing_time: float
    created_at: datetime
    
    class Config:
        from_attributes = True
```

---

## ğŸ§  æ ¸å¿ƒç®—æ³•è®¾è®¡

### æç¤ºè¯ä¼˜åŒ–å™¨

```python
# core/prompt_optimizer.py
from typing import Dict, List, Any
from abc import ABC, abstractmethod

class PromptOptimizer(ABC):
    """æç¤ºè¯ä¼˜åŒ–å™¨åŸºç±»"""
    
    @abstractmethod
    async def optimize(self, prompt: str, context: Dict[str, Any]) -> Dict[str, Any]:
        pass

class AIPromptOptimizer(PromptOptimizer):
    """åŸºäºAIçš„æç¤ºè¯ä¼˜åŒ–å™¨"""
    
    def __init__(self, ai_client: AIClient):
        self.ai_client = ai_client
        self.optimization_templates = self._load_templates()
    
    async def optimize(self, prompt: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        ä¼˜åŒ–æç¤ºè¯
        
        Args:
            prompt: åŸå§‹æç¤ºè¯
            context: ä¸Šä¸‹æ–‡ä¿¡æ¯
            
        Returns:
            ä¼˜åŒ–ç»“æœ
        """
        # 1. åˆ†æåŸå§‹æç¤ºè¯
        analysis = await self._analyze_prompt(prompt)
        
        # 2. ç¡®å®šä¼˜åŒ–ç­–ç•¥
        strategies = self._determine_strategies(analysis, context)
        
        # 3. åº”ç”¨ä¼˜åŒ–ç­–ç•¥
        optimized_prompt = await self._apply_strategies(prompt, strategies)
        
        # 4. ç”Ÿæˆæ”¹è¿›è¯´æ˜
        improvements = await self._generate_improvements(prompt, optimized_prompt, strategies)
        
        return {
            "optimized_prompt": optimized_prompt,
            "improvements": improvements,
            "strategies_used": strategies
        }
    
    async def _analyze_prompt(self, prompt: str) -> Dict[str, Any]:
        """åˆ†ææç¤ºè¯ç‰¹å¾"""
        analysis_prompt = f"""
        è¯·åˆ†æä»¥ä¸‹æç¤ºè¯çš„ç‰¹å¾ï¼š
        
        æç¤ºè¯ï¼š{prompt}
        
        è¯·ä»ä»¥ä¸‹ç»´åº¦åˆ†æï¼š
        1. æ¸…æ™°åº¦ (1-10åˆ†)
        2. å®Œæ•´æ€§ (1-10åˆ†)
        3. ç»“æ„æ€§ (1-10åˆ†)
        4. å…·ä½“æ€§ (1-10åˆ†)
        
        è¿”å›JSONæ ¼å¼ç»“æœã€‚
        """
        
        response = await self.ai_client.complete(analysis_prompt)
        return self._parse_analysis_response(response)
    
    def _determine_strategies(self, analysis: Dict, context: Dict) -> List[str]:
        """ç¡®å®šä¼˜åŒ–ç­–ç•¥"""
        strategies = []
        
        if analysis.get("clarity_score", 0) < 7:
            strategies.append("improve_clarity")
        
        if analysis.get("structure_score", 0) < 7:
            strategies.append("add_structure")
        
        if analysis.get("completeness_score", 0) < 7:
            strategies.append("add_context")
            
        if context.get("optimization_type") == "code":
            strategies.append("add_code_specifics")
            
        return strategies
```

### è´¨é‡è¯„ä¼°å™¨

```python
# core/quality_evaluator.py
class QualityEvaluator:
    """æç¤ºè¯è´¨é‡è¯„ä¼°å™¨"""
    
    def __init__(self, ai_client: AIClient):
        self.ai_client = ai_client
        self.evaluation_criteria = {
            "clarity": "æŒ‡ä»¤æ˜¯å¦æ¸…æ™°æ˜ç¡®",
            "completeness": "æ˜¯å¦åŒ…å«å¿…è¦ä¿¡æ¯",
            "structure": "é€»è¾‘ç»“æ„æ˜¯å¦æ¸…æ™°",
            "specificity": "æ˜¯å¦è¶³å¤Ÿå…·ä½“",
            "actionability": "AIæ˜¯å¦èƒ½å¤Ÿæ‰§è¡Œ"
        }
    
    async def evaluate(self, prompt: str) -> Dict[str, Any]:
        """è¯„ä¼°æç¤ºè¯è´¨é‡"""
        scores = {}
        issues = []
        suggestions = []
        
        for criterion, description in self.evaluation_criteria.items():
            score = await self._evaluate_criterion(prompt, criterion, description)
            scores[criterion] = score
            
            if score < 7:
                issue, suggestion = await self._generate_feedback(prompt, criterion, score)
                issues.append(issue)
                suggestions.append(suggestion)
        
        overall_score = sum(scores.values()) / len(scores)
        
        return {
            "overall_score": round(overall_score),
            "detailed_scores": scores,
            "issues": issues,
            "suggestions": suggestions
        }
```

---

## ğŸ” å®‰å…¨æ€§è®¾è®¡

### è®¤è¯å’Œæˆæƒ

```python
# utils/security.py
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class SecurityManager:
    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.access_token_expire_minutes = 30
    
    def create_access_token(self, data: dict) -> str:
        """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)
        to_encode.update({"exp": expire})
        
        return jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> dict:
        """éªŒè¯ä»¤ç‰Œ"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except JWTError:
            raise HTTPException(status_code=401, detail="Invalid token")
    
    @staticmethod
    def hash_password(password: str) -> str:
        """å¯†ç å“ˆå¸Œ"""
        return pwd_context.hash(password)
    
    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """éªŒè¯å¯†ç """
        return pwd_context.verify(plain_password, hashed_password)
```

### æ•°æ®éªŒè¯å’Œæ¸…ç†

```python
# utils/validators.py
import re
from typing import Any
from pydantic import validator

class PromptValidator:
    """æç¤ºè¯éªŒè¯å™¨"""
    
    @staticmethod
    def validate_prompt_content(prompt: str) -> str:
        """éªŒè¯æç¤ºè¯å†…å®¹"""
        # ç§»é™¤å±é™©å­—ç¬¦
        cleaned = re.sub(r'[<>"\']', '', prompt)
        
        # é•¿åº¦æ£€æŸ¥
        if len(cleaned) > 10000:
            raise ValueError("æç¤ºè¯é•¿åº¦ä¸èƒ½è¶…è¿‡10000å­—ç¬¦")
        
        if len(cleaned.strip()) < 1:
            raise ValueError("æç¤ºè¯ä¸èƒ½ä¸ºç©º")
        
        return cleaned.strip()
    
    @staticmethod
    def validate_optimization_type(opt_type: str) -> str:
        """éªŒè¯ä¼˜åŒ–ç±»å‹"""
        allowed_types = ["general", "code", "writing", "analysis"]
        if opt_type not in allowed_types:
            raise ValueError(f"ä¼˜åŒ–ç±»å‹å¿…é¡»æ˜¯ä»¥ä¸‹ä¹‹ä¸€: {allowed_types}")
        return opt_type
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### ç¼“å­˜ç­–ç•¥

```python
# services/cache_service.py
import redis.asyncio as redis
import json
from typing import Any, Optional

class CacheService:
    """ç¼“å­˜æœåŠ¡"""
    
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url)
    
    async def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜"""
        data = await self.redis.get(key)
        if data:
            return json.loads(data)
        return None
    
    async def set(self, key: str, value: Any, expire: int = 3600) -> None:
        """è®¾ç½®ç¼“å­˜"""
        await self.redis.setex(key, expire, json.dumps(value))
    
    async def delete(self, key: str) -> None:
        """åˆ é™¤ç¼“å­˜"""
        await self.redis.delete(key)
    
    def generate_optimization_cache_key(self, prompt: str, opt_type: str) -> str:
        """ç”Ÿæˆä¼˜åŒ–ç¼“å­˜é”®"""
        import hashlib
        content = f"{prompt}:{opt_type}"
        return f"optimization:{hashlib.md5(content.encode()).hexdigest()}"
```

### å¼‚æ­¥ä»»åŠ¡å¤„ç†

```python
# core/task_manager.py
from celery import Celery
from app.core.prompt_optimizer import AIPromptOptimizer

celery_app = Celery(
    "prompt_optimizer",
    broker="redis://localhost:6379/0",
    backend="redis://localhost:6379/0"
)

@celery_app.task
async def optimize_prompt_task(prompt: str, optimization_type: str, user_id: int):
    """å¼‚æ­¥ä¼˜åŒ–ä»»åŠ¡"""
    optimizer = AIPromptOptimizer()
    result = await optimizer.optimize(prompt, {"optimization_type": optimization_type})
    
    # ä¿å­˜ç»“æœåˆ°æ•°æ®åº“
    # ... æ•°æ®åº“æ“ä½œ
    
    return result
```

---

## ğŸš¨ é”™è¯¯å¤„ç†å’Œæ—¥å¿—

### å¼‚å¸¸å¤„ç†

```python
# utils/exceptions.py
from fastapi import HTTPException

class PromptOptimizerException(Exception):
    """åŸºç¡€å¼‚å¸¸ç±»"""
    def __init__(self, message: str, error_code: str = None):
        self.message = message
        self.error_code = error_code
        super().__init__(self.message)

class OptimizationFailedException(PromptOptimizerException):
    """ä¼˜åŒ–å¤±è´¥å¼‚å¸¸"""
    pass

class AIServiceException(PromptOptimizerException):
    """AIæœåŠ¡å¼‚å¸¸"""
    pass

class ValidationException(PromptOptimizerException):
    """éªŒè¯å¼‚å¸¸"""
    pass

# å…¨å±€å¼‚å¸¸å¤„ç†å™¨
from fastapi import Request
from fastapi.responses import JSONResponse

async def prompt_optimizer_exception_handler(request: Request, exc: PromptOptimizerException):
    return JSONResponse(
        status_code=400,
        content={
            "error": exc.error_code or "UNKNOWN_ERROR",
            "message": exc.message,
            "timestamp": datetime.utcnow().isoformat()
        }
    )
```

### æ—¥å¿—ç³»ç»Ÿ

```python
# utils/logging.py
from loguru import logger
import sys
from pathlib import Path

def setup_logging():
    """é…ç½®æ—¥å¿—ç³»ç»Ÿ"""
    # ç§»é™¤é»˜è®¤å¤„ç†å™¨
    logger.remove()
    
    # æ§åˆ¶å°æ—¥å¿—
    logger.add(
        sys.stdout,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        level="INFO"
    )
    
    # æ–‡ä»¶æ—¥å¿—
    logger.add(
        "logs/app.log",
        rotation="1 day",
        retention="30 days",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function}:{line} - {message}",
        level="DEBUG"
    )
    
    # é”™è¯¯æ—¥å¿—
    logger.add(
        "logs/error.log",
        level="ERROR",
        rotation="1 week",
        retention="3 months"
    )

# æ—¥å¿—è£…é¥°å™¨
from functools import wraps

def log_execution_time(func):
    """è®°å½•å‡½æ•°æ‰§è¡Œæ—¶é—´"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            execution_time = time.time() - start_time
            logger.info(f"{func.__name__} executed in {execution_time:.2f}s")
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"{func.__name__} failed after {execution_time:.2f}s: {str(e)}")
            raise
    return wrapper
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### æµ‹è¯•æ¶æ„

```python
# tests/conftest.py
import pytest
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from app.database import Base, DatabaseManager
from app.main import app

@pytest.fixture(scope="session")
def event_loop():
    """åˆ›å»ºäº‹ä»¶å¾ªç¯"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
async def db_session():
    """æµ‹è¯•æ•°æ®åº“ä¼šè¯"""
    engine = create_async_engine("sqlite+aiosqlite:///:memory:")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    async with AsyncSession(engine) as session:
        yield session

@pytest.fixture
def test_client():
    """æµ‹è¯•å®¢æˆ·ç«¯"""
    from fastapi.testclient import TestClient
    return TestClient(app)
```

### APIæµ‹è¯•ç¤ºä¾‹

```python
# tests/test_api/test_optimizer.py
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_optimize_prompt(test_client, mock_ai_client):
    """æµ‹è¯•æç¤ºè¯ä¼˜åŒ–æ¥å£"""
    # å‡†å¤‡æµ‹è¯•æ•°æ®
    request_data = {
        "original_prompt": "å†™ä¸ªå‡½æ•°",
        "optimization_type": "code"
    }
    
    # å‘é€è¯·æ±‚
    response = await test_client.post("/api/v1/optimizer/optimize", json=request_data)
    
    # éªŒè¯å“åº”
    assert response.status_code == 200
    data = response.json()
    assert "optimized_prompt" in data
    assert "quality_score_after" in data
    assert data["quality_score_after"] > 0

@pytest.mark.asyncio
async def test_evaluate_prompt_quality(test_client):
    """æµ‹è¯•è´¨é‡è¯„ä¼°æ¥å£"""
    request_data = {"prompt": "å¸®æˆ‘å†™ä»£ç "}
    
    response = await test_client.post("/api/v1/optimizer/evaluate", json=request_data)
    
    assert response.status_code == 200
    data = response.json()
    assert "overall_score" in data
    assert 0 <= data["overall_score"] <= 10
```

---

## ğŸ³ éƒ¨ç½²é…ç½®

### Dockeré…ç½®

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# åˆ›å»ºérootç”¨æˆ·
RUN useradd --create-home --shell /bin/bash app
USER app

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Docker Composeé…ç½®

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql+asyncpg://user:password@db:5432/prompt_optimizer
      - REDIS_URL=redis://redis:6379/0
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/app/logs

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=prompt_optimizer
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  worker:
    build: .
    command: celery -A app.core.task_manager worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql+asyncpg://user:password@db:5432/prompt_optimizer
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis

volumes:
  postgres_data:
```

---

## ğŸ“ å¼€å‘è§„èŒƒ

### ä»£ç è§„èŒƒ

```python
# pyproject.toml
[tool.black]
line-length = 88
target-version = ['py311']

[tool.isort]
profile = "black"
multi_line_output = 3

[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = "-v --tb=short"
```

### Git Hooksé…ç½®

```bash
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/psf/black
    rev: 23.3.0
    hooks:
      - id: black

  - repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
      - id: isort

  - repo: https://github.com/pycqa/flake8
    rev: 6.0.0
    hooks:
      - id: flake8

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.3.0
    hooks:
      - id: mypy
```

---

## ğŸ“Š ç›‘æ§å’Œéƒ¨ç½²

### å¥åº·æ£€æŸ¥

```python
# api/v1/health.py
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_async_session

router = APIRouter(prefix="/health", tags=["health"])

@router.get("/")
async def health_check():
    """åŸºç¡€å¥åº·æ£€æŸ¥"""
    return {"status": "healthy", "timestamp": datetime.utcnow()}

@router.get("/db")
async def database_health_check(db: AsyncSession = Depends(get_async_session)):
    """æ•°æ®åº“å¥åº·æ£€æŸ¥"""
    try:
        await db.execute("SELECT 1")
        return {"status": "healthy", "database": "connected"}
    except Exception as e:
        return {"status": "unhealthy", "database": str(e)}
```

---

**æ–‡æ¡£åˆ›å»ºæ—¥æœŸ**ï¼š2024å¹´12æœˆ
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0
**æœ€åæ›´æ–°**ï¼š2024å¹´12æœˆ


> æœ¬æ–‡æ¡£å°†éšç€é¡¹ç›®å¼€å‘è¿›å±•æŒç»­æ›´æ–°ï¼Œè¯·ç¡®ä¿ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬ã€‚ 